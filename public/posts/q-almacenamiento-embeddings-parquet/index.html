<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet | Omar Valdez G</title><meta name=keywords content="database,rag,vectorial"><meta name=description content="Â¿CuÃ¡ndo necesitas realmente una base de datos vectorial?"><meta name=author content="Omar Valdez G"><link rel=canonical href=http://localhost:1313/posts/q-almacenamiento-embeddings-parquet/><link crossorigin=anonymous href=/assets/css/stylesheet.41163b9ab2122008ead4e34b52cda72444f0291450b642c1db4b84cc26f2863d.css integrity="sha256-QRY7mrISIAjq1ONLUs2nJETwKRRQtkLB20uEzCbyhj0=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://localhost:1313/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/favicon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/favicon/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/q-almacenamiento-embeddings-parquet/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel=stylesheet><script src=https://unpkg.com/typeit@8.7.1/dist/index.umd.js></script><style>body{font-family:iosevka nerd font bold,monospace}</style><meta property="og:title" content="Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet"><meta property="og:description" content="Â¿CuÃ¡ndo necesitas realmente una base de datos vectorial?"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/q-almacenamiento-embeddings-parquet/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-19T00:00:00+00:00"><meta property="article:modified_time" content="2025-11-19T00:00:00+00:00"><meta property="og:site_name" content="Omar Valdez G"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet"><meta name=twitter:description content="Â¿CuÃ¡ndo necesitas realmente una base de datos vectorial?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet","item":"http://localhost:1313/posts/q-almacenamiento-embeddings-parquet/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet","name":"Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet","description":"Â¿CuÃ¡ndo necesitas realmente una base de datos vectorial?","keywords":["database","rag","vectorial"],"articleBody":"Contexto: En proyectos de bÃºsqueda semÃ¡ntica y RAG, muchos equipos asumen que necesitan bases de datos vectoriales especializadas desde el inicio, sin considerar alternativas mÃ¡s simples para conjuntos de datos pequeÃ±os y medianos.\nPREGUNTA EstÃ¡s desarrollando un sistema de bÃºsqueda semÃ¡ntica para documentaciÃ³n interna de tu empresa con aproximadamente 25,000 artÃ­culos. Ya generaste embeddings de 768 dimensiones usando un modelo BERT y necesitas decidir cÃ³mo almacenarlos. El equipo de infraestructura estÃ¡ preocupado por los costos operativos, pero el equipo de producto requiere latencias subâ€‘5â€¯ms para bÃºsquedas con filtros por categorÃ­a y fecha. Tu arquitectura debe ser portable entre ambientes de desarrollo local y producciÃ³n en AWS.\nÂ¿CuÃ¡l es el enfoque mÃ¡s apropiado para este escenario?\nA) Implementar Qdrant con Ã­ndices HNSW en Docker, priorizando latencia subâ€‘1â€¯ms sobre simplicidad operativa B) Usar archivos Parquet con Polars para bÃºsqueda lineal, aprovechando el formato columnar y conversiÃ³n zeroâ€‘copy a NumPy C) Almacenar embeddings en PostgreSQL con extensiÃ³n pgvector y Ã­ndices HNSW para obtener 471â€¯QPS a escala D) Guardar embeddings en archivos CSV con pandas por familiaridad del equipo y facilidad de debugging RESPUESTA: B\nEXPLICACIÃ“N La opciÃ³n B es correcta porque 25â€¯000 vectores con 768 dimensiones ocupan aproximadamente 73â€¯MB en memoria (25â€¯kâ€¯Ã—â€¯768â€¯Ã—â€¯4â€¯bytes), un tamaÃ±o manejable donde la bÃºsqueda lineal alcanza latencias de 1â€‘2â€¯ms segÃºn benchmarks reales.\nParquet ofrece compresiÃ³n ~6Ã— superior a CSV, soporte nativo para arrays tipados (p.ej. List(Float32)) y acceso columnar selectivo, lo que permite cargar solo los embeddings y los metadatos necesarios. Polars permite una conversiÃ³n zeroâ€‘copy a NumPy, de modo que las operaciones vectorizadas de producto punto se ejecutan sin overhead de serializaciÃ³n. Este enfoque cumple el requisito de subâ€‘5â€¯ms, evita la complejidad de Docker/configuraciÃ³n y mantiene una portabilidad perfecta mediante un Ãºnico archivo. Por quÃ© fallan las otras opciones A y C â€“ Bases de datos vectoriales con HNSW son sobreâ€‘ingenierÃ­a para este tamaÃ±o de dataset; su mayor ventaja aparece a partir de ~100â€¯k vectores, donde la bÃºsqueda lineal O(n) se vuelve prohibitiva. D â€“ CSV consume ~6Ã— mÃ¡s espacio, requiere parseo completo del archivo y pandas trata listas como objetos genÃ©ricos, lo que penaliza gravemente el rendimiento frente al soporte nativo de Polars para pl.List. EJEMPLO REAL El proyecto Magic: The Gathering implementÃ³ bÃºsqueda sobre 32â€¯254 cartas con embeddings de 768â€¯D usando exactamente esta arquitectura, logrando consultas filtradas por metadatos en 1.48â€¯ms.\nEl sistema permite bÃºsquedas semÃ¡nticas complejas como â€œcartas similares a Lightning Helix pero solo Sorceries con mana Blackâ€ aplicando filtros de Polars antes de calcular similitud coseno mediante producto punto en NumPy.\nTodo funciona desde un archivo Parquet portable sin infraestructura de base de datos, demostrando que 94â€¯MB de embeddings (32â€¯kâ€¯Ã—â€¯768â€¯Ã—â€¯4â€¯bytes) operan perfectamente en la memoria de laptops modernas con latencias aceptables para usuarios finales.\nCONSEJO CLAVE Benchmarkea tu caso de uso real antes de adoptar bases de datos vectoriales. Regla prÃ¡ctica: si tu dataset completo cabe en memoria (~100â€¯k vectores o menos), la bÃºsqueda lineal con Parquetâ€¯+â€¯Polars ofrece latencias subâ€‘2â€¯ms sin overhead operacional.\nEscala a soluciones indexadas (HNSW/IVF) solo cuando los datasets superen los 100â€¯k vectores o necesites consultas distribuidas.\nREFERENCIAS Almacenamiento portÃ¡til de embeddings con Parquet y Polars - minimaxir.com Formato columnar Parquet: beneficios y mejores prÃ¡cticas - Airbyte Interoperabilidad zeroâ€‘copy entre Polars y NumPy - Polars Blog ","wordCount":"564","inLanguage":"en","datePublished":"2025-11-19T00:00:00Z","dateModified":"2025-11-19T00:00:00Z","author":{"@type":"Person","name":"Omar Valdez G"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/q-almacenamiento-embeddings-parquet/"},"publisher":{"@type":"Organization","name":"Omar Valdez G","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="~$ cd .. (Alt + H)"><img src=http://localhost:1313/favicon/favicon.ico alt aria-label=logo height=35>~$ cd ..</a><div class=logo-switches><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title=ğŸ”><span>ğŸ”</span></a></li><li><a href=http://localhost:1313/dotfiles/ title="â€¢ dots"><span>â€¢ dots</span></a></li><li><a href=http://localhost:1313/tags/ title="â€¢ tags"><span>â€¢ tags</span></a></li><li><a href=http://localhost:1313/newsletter title="â€¢ newsletter"><span>â€¢ newsletter</span></a></li><li><a href=http://localhost:1313/posts/ title="â€¢ posts"><span>â€¢ posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet</h1><div class=post-meta></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#pregunta aria-label=PREGUNTA>PREGUNTA</a></li><li><a href=#explicaci%c3%b3n aria-label=EXPLICACIÃ“N>EXPLICACIÃ“N</a><ul><li><a href=#por-qu%c3%a9-fallan-las-otras-opciones aria-label="Por quÃ© fallan las otras opciones">Por quÃ© fallan las otras opciones</a></li></ul></li><li><a href=#ejemplo-real aria-label="EJEMPLO REAL">EJEMPLO REAL</a></li><li><a href=#consejo-clave aria-label="CONSEJO CLAVE">CONSEJO CLAVE</a></li><li><a href=#referencias aria-label=REFERENCIAS>REFERENCIAS</a></li></ul></div></details></div><div class=post-content><p><em><strong>Contexto</strong>: En proyectos de bÃºsqueda semÃ¡ntica y RAG, muchos equipos asumen que necesitan bases de datos vectoriales especializadas desde el inicio, sin considerar alternativas mÃ¡s simples para conjuntos de datos pequeÃ±os y medianos.</em></p><h3 id=pregunta>PREGUNTA<a hidden class=anchor aria-hidden=true href=#pregunta>#</a></h3><p>EstÃ¡s desarrollando un sistema de bÃºsqueda semÃ¡ntica para documentaciÃ³n interna de tu empresa con aproximadamente 25,000 artÃ­culos. Ya generaste embeddings de 768 dimensiones usando un modelo BERT y necesitas decidir cÃ³mo almacenarlos. El equipo de infraestructura estÃ¡ preocupado por los costos operativos, pero el equipo de producto requiere latencias subâ€‘5â€¯ms para bÃºsquedas con filtros por categorÃ­a y fecha. Tu arquitectura debe ser portable entre ambientes de desarrollo local y producciÃ³n en AWS.</p><p><strong>Â¿CuÃ¡l es el enfoque mÃ¡s apropiado para este escenario?</strong></p><p>Â </p><ul><li>A) Implementar Qdrant con Ã­ndices HNSW en Docker, priorizando latencia subâ€‘1â€¯ms sobre simplicidad operativa</li><li>B) Usar archivos Parquet con Polars para bÃºsqueda lineal, aprovechando el formato columnar y conversiÃ³n zeroâ€‘copy a NumPy</li><li>C) Almacenar embeddings en PostgreSQL con extensiÃ³n pgvector y Ã­ndices HNSW para obtener 471â€¯QPS a escala</li><li>D) Guardar embeddings en archivos CSV con pandas por familiaridad del equipo y facilidad de debugging</li></ul><p>Â </p><p><strong>RESPUESTA: B</strong></p><h3 id=explicaciÃ³n>EXPLICACIÃ“N<a hidden class=anchor aria-hidden=true href=#explicaciÃ³n>#</a></h3><p>La opciÃ³n <strong>B</strong> es correcta porque 25â€¯000 vectores con 768 dimensiones ocupan aproximadamente <strong>73â€¯MB</strong> en memoria (25â€¯kâ€¯Ã—â€¯768â€¯Ã—â€¯4â€¯bytes), un tamaÃ±o manejable donde la bÃºsqueda lineal alcanza latencias de <strong>1â€‘2â€¯ms</strong> segÃºn benchmarks reales.</p><ul><li><strong>Parquet</strong> ofrece compresiÃ³n ~6Ã— superior a CSV, soporte nativo para arrays tipados (p.ej. <code>List(Float32)</code>) y acceso columnar selectivo, lo que permite cargar solo los embeddings y los metadatos necesarios.</li><li><strong>Polars</strong> permite una conversiÃ³n <em>zeroâ€‘copy</em> a NumPy, de modo que las operaciones vectorizadas de producto punto se ejecutan sin overhead de serializaciÃ³n.</li><li>Este enfoque cumple el requisito de subâ€‘5â€¯ms, evita la complejidad de Docker/configuraciÃ³n y mantiene una <strong>portabilidad perfecta</strong> mediante un Ãºnico archivo.</li></ul><h4 id=por-quÃ©-fallan-las-otras-opciones>Por quÃ© fallan las otras opciones<a hidden class=anchor aria-hidden=true href=#por-quÃ©-fallan-las-otras-opciones>#</a></h4><ul><li><strong>A y C</strong> â€“ Bases de datos vectoriales con HNSW son sobreâ€‘ingenierÃ­a para este tamaÃ±o de dataset; su mayor ventaja aparece a partir de ~100â€¯k vectores, donde la bÃºsqueda lineal O(n) se vuelve prohibitiva.</li><li><strong>D</strong> â€“ CSV consume ~6Ã— mÃ¡s espacio, requiere parseo completo del archivo y pandas trata listas como objetos genÃ©ricos, lo que penaliza gravemente el rendimiento frente al soporte nativo de Polars para <code>pl.List</code>.</li></ul><h3 id=ejemplo-real>EJEMPLO REAL<a hidden class=anchor aria-hidden=true href=#ejemplo-real>#</a></h3><p>El proyecto <strong>Magic: The Gathering</strong> implementÃ³ bÃºsqueda sobre 32â€¯254 cartas con embeddings de 768â€¯D usando exactamente esta arquitectura, logrando consultas filtradas por metadatos en <strong>1.48â€¯ms</strong>.</p><p>El sistema permite bÃºsquedas semÃ¡nticas complejas como <em>â€œcartas similares a Lightning Helix pero solo Sorceries con mana Blackâ€</em> aplicando filtros de Polars antes de calcular similitud coseno mediante producto punto en NumPy.</p><p>Todo funciona desde un archivo <strong>Parquet</strong> portable sin infraestructura de base de datos, demostrando que <strong>94â€¯MB</strong> de embeddings (32â€¯kâ€¯Ã—â€¯768â€¯Ã—â€¯4â€¯bytes) operan perfectamente en la memoria de laptops modernas con latencias aceptables para usuarios finales.</p><h3 id=consejo-clave>CONSEJO CLAVE<a hidden class=anchor aria-hidden=true href=#consejo-clave>#</a></h3><p><strong>Benchmarkea tu caso de uso real antes de adoptar bases de datos vectoriales.</strong>
Regla prÃ¡ctica: si tu dataset completo cabe en memoria (~100â€¯k vectores o menos), la bÃºsqueda lineal con <strong>Parquetâ€¯+â€¯Polars</strong> ofrece latencias subâ€‘2â€¯ms sin overhead operacional.</p><p>Escala a soluciones indexadas (HNSW/IVF) solo cuando los datasets superen los 100â€¯k vectores o necesites consultas distribuidas.</p><h3 id=referencias>REFERENCIAS<a hidden class=anchor aria-hidden=true href=#referencias>#</a></h3><ul><li><a href=https://minimaxir.com/2025/02/embeddings-parquet/>Almacenamiento portÃ¡til de embeddings con Parquet y Polars - minimaxir.com</a></li><li><a href=https://airbyte.com/data-engineering-resources/parquet-data-format>Formato columnar Parquet: beneficios y mejores prÃ¡cticas - Airbyte</a></li><li><a href=https://pola.rs/posts/polars-in-aggregate-mar24/>Interoperabilidad zeroâ€‘copy entre Polars y NumPy - Polars Blog</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/database/>Database</a></li><li><a href=http://localhost:1313/tags/rag/>Rag</a></li><li><a href=http://localhost:1313/tags/vectorial/>Vectorial</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/q-arq-orquestacion-task-data/><span class=title>Â« Prev</span><br><span>Pregunta #3 - Arquitecturas de OrquestaciÃ³n: Task-Centric vs Data-Centric</span>
</a><a class=next href=http://localhost:1313/posts/q-modern-etl-testing-dbt-sqlmesh/><span class=title>Next Â»</span><br><span>Pregunta #5 - Modern ELT Testing en ProducciÃ³n: dbt vs. SQLMesh</span></a></nav><div class=newsletter-wrapper><script async src=https://eocampaign1.com/form/0d56db8e-de34-11f0-9838-c955fe4b6ecd.js data-form=0d56db8e-de34-11f0-9838-c955fe4b6ecd></script></div><div id=cusdis_thread data-host=https://cusdis.com data-app-id=f9b750aa-55fe-4da9-82cf-45aa511cea20 data-app-id=414adb98-9af8-4403-bdc5-ba55ae808bea data-page-id=3dfdada72f76f62d09bdaec8ed990e3b data-page-url=http://localhost:1313/posts/q-almacenamiento-embeddings-parquet/ data-page-title="Pregunta #4 - Almacenamiento PortÃ¡til de Embeddings con Parquet"></div><script async defer src=https://cusdis.com/js/cusdis.es.js></script></footer></article></main><script async defer src=https://scripts.withcabin.com/hello.js></script></body></html>
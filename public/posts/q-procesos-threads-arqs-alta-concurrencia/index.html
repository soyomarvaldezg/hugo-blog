<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia | Omar Valdez G</title><meta name=keywords content="threads,concurrency,architecture"><meta name=description content="El trade-off fundamental que define la estabilidad y performance de tu sistema"><meta name=author content="Omar Valdez G"><link rel=canonical href=http://localhost:1313/posts/q-procesos-threads-arqs-alta-concurrencia/><link crossorigin=anonymous href=/assets/css/stylesheet.d8bb4da40dcec890935558078b7b18d1baf46e84a80ea4cc9702a8734954dbff.css integrity="sha256-2LtNpA3OyJCTVVgHi3sY0br0boSoDqTMlwKoc0lU2/8=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=http://localhost:1313/favicon/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/favicon/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/favicon/favicon-16x16.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/q-procesos-threads-arqs-alta-concurrencia/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code&display=swap" rel=stylesheet><script src=https://unpkg.com/typeit@8.7.1/dist/index.umd.js></script><style>body{font-family:iosevka nerd font bold,monospace}</style><meta property="og:title" content="Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia"><meta property="og:description" content="El trade-off fundamental que define la estabilidad y performance de tu sistema"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/q-procesos-threads-arqs-alta-concurrencia/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-12-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-12-10T00:00:00+00:00"><meta property="og:site_name" content="Omar Valdez G"><meta name=twitter:card content="summary"><meta name=twitter:title content="Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia"><meta name=twitter:description content="El trade-off fundamental que define la estabilidad y performance de tu sistema"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia","item":"http://localhost:1313/posts/q-procesos-threads-arqs-alta-concurrencia/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia","name":"Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia","description":"El trade-off fundamental que define la estabilidad y performance de tu sistema","keywords":["threads","concurrency","architecture"],"articleBody":"Contexto: La elecci√≥n entre procesos y threads determina c√≥mo tu sistema maneja concurrencia, aislamiento y escalabilidad. Esta decisi√≥n arquitect√≥nica afecta directamente el consumo de memoria, velocidad de context switching y tolerancia a fallos de tu aplicaci√≥n\nPREGUNTA Est√°s dise√±ando un servicio backend cr√≠tico para procesamiento de transacciones financieras que debe manejar 5,000 conexiones concurrentes.\nEl sistema ejecutar√° queries complejas con datos sensibles y un error en una conexi√≥n no debe comprometer las dem√°s.\nTu infraestructura tiene servidores con 16 cores y 64GB de RAM. El equipo debate entre dos arquitecturas:\nArquitectura A: Modelo process-per-connection (similar a PostgreSQL) con ~10MB overhead por proceso y ~5Œºs de context switch.\nArquitectura B: Modelo thread-per-connection (similar a MySQL) con ~1-2MB overhead por thread y ~1Œºs de context switch.\n¬øQu√© arquitectura elegir√≠as y por qu√©?\nA) Arquitectura A con procesos, porque el aislamiento de memoria es cr√≠tico para datos financieros, pero usando connection pooling (PgBouncer) para reducir a ~50 procesos reales\nB) Arquitectura B con threads, porque 5,000 threads √ó 2MB = 10GB es manejable y el context switch 5√ó m√°s r√°pido maximiza throughput\nC) Arquitectura B con threads m√°s async I/O tipo Nginx para manejar las 5,000 conexiones con solo 16 workers (uno por core)\nD) Arquitectura A con procesos directamente, porque aunque consuma 50GB (5,000 √ó 10MB), la estabilidad justifica el costo en sistemas financieros\nRESPUESTA: A\nEXPLICACI√ìN La opci√≥n A es correcta porque combina lo mejor de ambos mundos para el caso de uso espec√≠fico. En sistemas financieros cr√≠ticos, el aislamiento de memoria que proveen los procesos es fundamental: si una conexi√≥n accede a memoria inv√°lida o crashea, solo ese proceso muere sin afectar el servidor completo.\nPostgreSQL eligi√≥ este modelo precisamente por esta raz√≥n de estabilidad. Sin embargo, 5,000 procesos directos consumir√≠an ~50GB solo en overhead, m√°s el thrashing por context switching excesivo.\nLa soluci√≥n es connection pooling con herramientas como PgBouncer o pgcat.\nEl pooler mantiene 5,000 conexiones de clientes pero solo ~50 conexiones reales al servidor (aproximadamente cores √ó 3), reutiliz√°ndolas inteligentemente.\nEsto reduce el overhead de 50GB a ~500MB manteniendo el aislamiento cr√≠tico. Es la arquitectura recomendada para producci√≥n con PostgreSQL.\nPor qu√© las otras opciones son incorrectas:\nLa opci√≥n B falla porque threads comparten memoria‚Äîun thread corrupto puede comprometer todo el proceso mysqld. La opci√≥n C (async I/O) no provee aislamiento entre conexiones y es compleja para queries CPU-bound. La opci√≥n D es t√©cnicamente posible pero derrocha recursos: 50GB de overhead m√°s thrashing har√≠an el sistema ineficiente cuando el pooling resuelve ambos problemas. EJEMPLO REAL Instagram y Notion ejecutan PostgreSQL a escala masiva usando exactamente esta estrategia: proceso-per-connection con pooling agresivo.\nInstagram maneja millones de usuarios con PgBouncer funneling miles de conexiones cliente a decenas de workers PostgreSQL.\nGitHub usa un modelo similar para su flota MySQL pero con connection pooling para evitar el overhead de threads.\nEn PlanetScale, el equipo que construy√≥ Google Cloud SQL (uno de los servicios hosted m√°s grandes de MySQL y Postgres) recomienda siempre usar poolers en producci√≥n independientemente del modelo elegido.\nCONSEJO CLAVE La regla de oro es: workers ‚âà n√∫mero de cores, no n√∫mero de conexiones. Para CPU-bound work, m√°s workers que cores solo a√±ade overhead de context switching sin ganancia. Usa connection pooling como capa intermedia que mapea N conexiones cliente a M workers donde M ‚âà cores √ó multiplicador (t√≠picamente 3-5). Monitorea context switches con vmstat o pidstat‚Äîrates excesivos indican thrashing.\nREFERENCIAS https://planetscale.com/blog/processes-and-threads - Explicaci√≥n interactiva completa de procesos, threads y arquitecturas de PostgreSQL vs MySQL https://www.bytebase.com/blog/postgres-vs-mysql/ - Comparaci√≥n exhaustiva 2025 de modelos de conexi√≥n, performance y casos de uso https://dev.to/harry_do/part-1-mysql-vs-postgresql-connection-architecture-1nk9 - An√°lisis detallado de arquitecturas thread-based vs process-based con m√©tricas ","wordCount":"603","inLanguage":"en","datePublished":"2025-12-10T00:00:00Z","dateModified":"2025-12-10T00:00:00Z","author":{"@type":"Person","name":"Omar Valdez G"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/q-procesos-threads-arqs-alta-concurrencia/"},"publisher":{"@type":"Organization","name":"Omar Valdez G","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon/favicon.ico"}}}</script></head><body class=dark id=top><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="~$ cd .. (Alt + H)"><img src=http://localhost:1313/favicon/favicon.ico alt aria-label=logo height=35>~$ cd ..</a><div class=logo-switches><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=http://localhost:1313/search/ title=üîé><span>üîé</span></a></li><li><a href=http://localhost:1313/dotfiles/ title="‚Ä¢ dots"><span>‚Ä¢ dots</span></a></li><li><a href=http://localhost:1313/tags/ title="‚Ä¢ tags"><span>‚Ä¢ tags</span></a></li><li><a href=http://localhost:1313/newsletter title="‚Ä¢ newsletter"><span>‚Ä¢ newsletter</span></a></li><li><a href=http://localhost:1313/posts/ title="‚Ä¢ posts"><span>‚Ä¢ posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia</h1><div class=post-meta></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#pregunta aria-label=PREGUNTA>PREGUNTA</a></li><li><a href=#explicaci%c3%b3n aria-label=EXPLICACI√ìN>EXPLICACI√ìN</a></li><li><a href=#ejemplo-real aria-label="EJEMPLO REAL">EJEMPLO REAL</a></li><li><a href=#consejo-clave aria-label="CONSEJO CLAVE">CONSEJO CLAVE</a></li><li><a href=#referencias aria-label=REFERENCIAS>REFERENCIAS</a></li></ul></div></details></div><div class=post-content><p><em><strong>Contexto</strong>: La elecci√≥n entre procesos y threads determina c√≥mo tu sistema maneja concurrencia, aislamiento y escalabilidad. Esta decisi√≥n arquitect√≥nica afecta directamente el consumo de memoria, velocidad de context switching y tolerancia a fallos de tu aplicaci√≥n</em></p><h3 id=pregunta>PREGUNTA<a hidden class=anchor aria-hidden=true href=#pregunta>#</a></h3><p>Est√°s dise√±ando un servicio backend cr√≠tico para procesamiento de transacciones financieras que debe manejar 5,000 conexiones concurrentes.</p><p>El sistema ejecutar√° queries complejas con datos sensibles y un error en una conexi√≥n no debe comprometer las dem√°s.</p><p>Tu infraestructura tiene servidores con 16 cores y 64GB de RAM. El equipo debate entre dos arquitecturas:</p><p>Arquitectura A: Modelo process-per-connection (similar a PostgreSQL) con ~10MB overhead por proceso y ~5Œºs de context switch.</p><p>Arquitectura B: Modelo thread-per-connection (similar a MySQL) con ~1-2MB overhead por thread y ~1Œºs de context switch.</p><p><strong>¬øQu√© arquitectura elegir√≠as y por qu√©?</strong></p><p>¬†</p><p>A) Arquitectura A con procesos, porque el aislamiento de memoria es cr√≠tico para datos financieros, pero usando connection pooling (PgBouncer) para reducir a ~50 procesos reales</p><p>B) Arquitectura B con threads, porque 5,000 threads √ó 2MB = 10GB es manejable y el context switch 5√ó m√°s r√°pido maximiza throughput</p><p>C) Arquitectura B con threads m√°s async I/O tipo Nginx para manejar las 5,000 conexiones con solo 16 workers (uno por core)</p><p>D) Arquitectura A con procesos directamente, porque aunque consuma 50GB (5,000 √ó 10MB), la estabilidad justifica el costo en sistemas financieros</p><p>¬†</p><p><strong>RESPUESTA: A</strong></p><h3 id=explicaci√≥n>EXPLICACI√ìN<a hidden class=anchor aria-hidden=true href=#explicaci√≥n>#</a></h3><p>La opci√≥n A es correcta porque combina lo mejor de ambos mundos para el caso de uso espec√≠fico. En sistemas financieros cr√≠ticos, el aislamiento de memoria que proveen los procesos es fundamental: si una conexi√≥n accede a memoria inv√°lida o crashea, solo ese proceso muere sin afectar el servidor completo.</p><p>PostgreSQL eligi√≥ este modelo precisamente por esta raz√≥n de estabilidad. Sin embargo, 5,000 procesos directos consumir√≠an ~50GB solo en overhead, m√°s el thrashing por context switching excesivo.</p><p>La soluci√≥n es connection pooling con herramientas como PgBouncer o pgcat.</p><p>El pooler mantiene 5,000 conexiones de clientes pero solo ~50 conexiones reales al servidor (aproximadamente cores √ó 3), reutiliz√°ndolas inteligentemente.</p><p>Esto reduce el overhead de 50GB a ~500MB manteniendo el aislamiento cr√≠tico. Es la arquitectura recomendada para producci√≥n con PostgreSQL.</p><p>Por qu√© las otras opciones son incorrectas:</p><ul><li>La opci√≥n B falla porque threads comparten memoria‚Äîun thread corrupto puede comprometer todo el proceso mysqld.</li><li>La opci√≥n C (async I/O) no provee aislamiento entre conexiones y es compleja para queries CPU-bound.</li><li>La opci√≥n D es t√©cnicamente posible pero derrocha recursos: 50GB de overhead m√°s thrashing har√≠an el sistema ineficiente cuando el pooling resuelve ambos problemas.</li></ul><h3 id=ejemplo-real>EJEMPLO REAL<a hidden class=anchor aria-hidden=true href=#ejemplo-real>#</a></h3><p>Instagram y Notion ejecutan PostgreSQL a escala masiva usando exactamente esta estrategia: proceso-per-connection con pooling agresivo.</p><p>Instagram maneja millones de usuarios con PgBouncer funneling miles de conexiones cliente a decenas de workers PostgreSQL.</p><p>GitHub usa un modelo similar para su flota MySQL pero con connection pooling para evitar el overhead de threads.</p><p>En PlanetScale, el equipo que construy√≥ Google Cloud SQL (uno de los servicios hosted m√°s grandes de MySQL y Postgres) recomienda siempre usar poolers en producci√≥n independientemente del modelo elegido.</p><h3 id=consejo-clave>CONSEJO CLAVE<a hidden class=anchor aria-hidden=true href=#consejo-clave>#</a></h3><p>La regla de oro es: workers ‚âà n√∫mero de cores, no n√∫mero de conexiones. Para CPU-bound work, m√°s workers que cores solo a√±ade overhead de context switching sin ganancia. Usa connection pooling como capa intermedia que mapea N conexiones cliente a M workers donde M ‚âà cores √ó multiplicador (t√≠picamente 3-5). Monitorea context switches con vmstat o pidstat‚Äîrates excesivos indican thrashing.</p><h3 id=referencias>REFERENCIAS<a hidden class=anchor aria-hidden=true href=#referencias>#</a></h3><ul><li><a href=https://planetscale.com/blog/processes-and-threads>https://planetscale.com/blog/processes-and-threads</a> - Explicaci√≥n interactiva completa de procesos, threads y arquitecturas de PostgreSQL vs MySQL</li><li><a href=https://www.bytebase.com/blog/postgres-vs-mysql/>https://www.bytebase.com/blog/postgres-vs-mysql/</a> - Comparaci√≥n exhaustiva 2025 de modelos de conexi√≥n, performance y casos de uso</li><li><a href=https://dev.to/harry_do/part-1-mysql-vs-postgresql-connection-architecture-1nk9>https://dev.to/harry_do/part-1-mysql-vs-postgresql-connection-architecture-1nk9</a> - An√°lisis detallado de arquitecturas thread-based vs process-based con m√©tricas</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/threads/>Threads</a></li><li><a href=http://localhost:1313/tags/concurrency/>Concurrency</a></li><li><a href=http://localhost:1313/tags/architecture/>Architecture</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/q-criptogramas-prevencion-replay-attacks/><span class=title>¬´ Prev</span><br><span>Pregunta #9 - Criptogramas Din√°micos para Prevenci√≥n de Replay Attacks</span>
</a><a class=next href=http://localhost:1313/posts/q-design-runtime-lineage/><span class=title>Next ¬ª</span><br><span>Pregunta #11 - Design-Time vs Runtime Lineage: ¬øCu√°ndo Necesitas Cada Uno?</span></a></nav><div id=cusdis_thread data-host=https://cusdis.com data-app-id=f9b750aa-55fe-4da9-82cf-45aa511cea20 data-app-id=414adb98-9af8-4403-bdc5-ba55ae808bea data-page-id=5799589cd80ffe33eebee5dd277edfc4 data-page-url=http://localhost:1313/posts/q-procesos-threads-arqs-alta-concurrencia/ data-page-title="Pregunta #10 Procesos vs Threads en Arquitecturas de Alta Concurrencia"></div><script async defer src=https://cusdis.com/js/cusdis.es.js></script></footer></article></main><script async defer src=https://scripts.withcabin.com/hello.js></script></body></html>